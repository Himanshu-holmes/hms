package service

import (
	"context"
	"errors"       // For errors.Is
	"fmt"
	"log"
	"os"
	"strings" // For error message checking
	"time"

	 // Not directly used here but good to have if User model had UUID
	"github.com/himanshu-holmes/hms/internal/authentication"
	"github.com/himanshu-holmes/hms/internal/authorization"	
	"github.com/himanshu-holmes/hms/internal/db"
	"github.com/himanshu-holmes/hms/internal/mapper"
	"github.com/himanshu-holmes/hms/internal/model"
	"github.com/himanshu-holmes/hms/internal/repository"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var secret = []byte(os.Getenv("SECRET"))

var ErrUserNotFound = errors.New("user not found")
var ErrInvalidCredentials = errors.New("invalid username or password")
var ErrUserAlreadyExists = errors.New("username already exists")

type authService struct {
	userRepo repository.UserRepository
}

func NewAuthService(userRepo repository.UserRepository) AuthService {
	return &authService{userRepo: userRepo,}
}

func (s *authService) Login(ctx context.Context ,req model.LoginRequest) (*model.LoginResponse, error) {
	user, err := s.userRepo.GetUserByUsername(ctx ,req.Username)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrInvalidCredentials // More generic error for security
		}
		log.Printf("AuthService: Error fetching user by username '%s': %v", req.Username, err)
		return nil, fmt.Errorf("internal server error during login: %w", err)
	}
	


	if !authentication.CheckPasswordHash(req.Password, user.PasswordHash) {
		return nil, ErrInvalidCredentials
	}
//  generate token
      
      auth := authorization.NewAuthorization(secret, 24*time.Hour, 7*24*time.Hour)
	  accessToken,refreshToken, err := auth.Tokenize(ctx,user.ID.String(),user.Username,string(user.Role))
	if err != nil {
		log.Printf("AuthService: Error generating token for user ID %s: %v", user.ID, err)
		return nil, fmt.Errorf("error generating token: %w", err)
	}

	// Do not send password hash in response
	user.PasswordHash = ""

	formatUser := mapper.ConvertDBUserToModel(user)

	return &model.LoginResponse{AccessToken: accessToken, RefreshToken: refreshToken, User: formatUser}, nil
}

func (s *authService) CreateUser(ctx context.Context, req model.UserCreateRequest) (*model.User, error) {
	// Check if user already exists
	existingUser, err := s.userRepo.GetUserByUsername(ctx, req.Username)
	if err != nil && !errors.Is(err, pgx.ErrNoRows) { // If error is something other than "not found"
		log.Printf("AuthService: Error checking existing user '%s': %v", req.Username, err)
		return nil, fmt.Errorf("error checking existing user: %w", err)
	}
	if existingUser.Username == req.Username {
		return nil, ErrUserAlreadyExists
	}
	hashedPassword, err := authentication.HashPassword(req.Password)
	if err != nil {
		log.Printf("AuthService: Error hashing password for user '%s': %v", req.Username, err)
		return nil, fmt.Errorf("error hashing password: %w", err)
	}

	newUser := &db.CreateUserParams{
		// ID will be generated by DB or set by repo CreateUser
		Username:     req.Username,
		PasswordHash: hashedPassword,
	    Role:       db.UserRole(req.Role),
		FirstName: pgtype.Text{String: *req.FirstName, Valid: req.FirstName != nil},
		LastName:  pgtype.Text{String: *req.LastName, Valid: req.LastName != nil},
		Email:     pgtype.Text{String: *req.Email, Valid: req.Email != nil},
		IsActive:  pgtype.Bool{Bool: true, Valid: true},
	

	}

	user, err := s.userRepo.CreateUser(ctx,*newUser)
	if err != nil {
		// Check for unique constraint violation errors from the database
		// This might be DB-specific, e.g., "pq: duplicate key value violates unique constraint"
		if strings.Contains(strings.ToLower(err.Error()), "unique constraint") ||
			strings.Contains(strings.ToLower(err.Error()), "duplicate key") {
			return nil, ErrUserAlreadyExists
		}
		log.Printf("AuthService: Error creating user '%s' in repository: %v", req.Username, err)
		return nil, fmt.Errorf("error creating user: %w", err)
	}
	userID := user.ID // Set the ID returned by the repository

	// Fetch the full user record to get DB-generated fields like CreatedAt, UpdatedAt
	// (This assumes CreateUser in repo might not return all fields or you want to be sure)
	createdUser, err := s.userRepo.GetUserByID(ctx, userID)
	if err != nil {
		log.Printf("AuthService: Error fetching newly created user '%s' by ID %s: %v. Returning partially populated user.", req.Username, userID, err)
		// Still return the user object we have, but log the error
		partialUser := mapper.ConvertDBUserToModel(user)
		return &partialUser, nil
	}
	createdUser.PasswordHash = "" // Don't return hash
    mappedUser := mapper.ConvertDBUserToModel(user)
	return &mappedUser, nil
}