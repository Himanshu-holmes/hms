// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: patient_visit.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPatientVisit = `-- name: CreatePatientVisit :one
INSERT INTO patient_visits (
    patient_id, doctor_id, visit_date, symptoms, diagnosis, prescription, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, patient_id, doctor_id, visit_date, symptoms, diagnosis, prescription, notes, created_at, updated_at
`

type CreatePatientVisitParams struct {
	PatientID    pgtype.UUID
	DoctorID     pgtype.UUID
	VisitDate    pgtype.Timestamptz
	Symptoms     pgtype.Text
	Diagnosis    pgtype.Text
	Prescription pgtype.Text
	Notes        pgtype.Text
}

func (q *Queries) CreatePatientVisit(ctx context.Context, arg CreatePatientVisitParams) (PatientVisit, error) {
	row := q.db.QueryRow(ctx, createPatientVisit,
		arg.PatientID,
		arg.DoctorID,
		arg.VisitDate,
		arg.Symptoms,
		arg.Diagnosis,
		arg.Prescription,
		arg.Notes,
	)
	var i PatientVisit
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.VisitDate,
		&i.Symptoms,
		&i.Diagnosis,
		&i.Prescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePatientVisit = `-- name: DeletePatientVisit :exec
DELETE FROM patient_visits
WHERE id = $1
`

func (q *Queries) DeletePatientVisit(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePatientVisit, id)
	return err
}

const getPatientVisitByID = `-- name: GetPatientVisitByID :one
SELECT id, patient_id, doctor_id, visit_date, symptoms, diagnosis, prescription, notes, created_at, updated_at FROM patient_visits
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPatientVisitByID(ctx context.Context, id pgtype.UUID) (PatientVisit, error) {
	row := q.db.QueryRow(ctx, getPatientVisitByID, id)
	var i PatientVisit
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.VisitDate,
		&i.Symptoms,
		&i.Diagnosis,
		&i.Prescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPatientVisitsByDoctorID = `-- name: ListPatientVisitsByDoctorID :many
SELECT pv.id, pv.patient_id, pv.doctor_id, pv.visit_date, pv.symptoms, pv.diagnosis, pv.prescription, pv.notes, pv.created_at, pv.updated_at, p.first_name as patient_first_name, p.last_name as patient_last_name
FROM patient_visits pv
JOIN patients p ON pv.patient_id = p.id -- Join to get patient's name
WHERE pv.doctor_id = $1
ORDER BY pv.visit_date DESC
LIMIT $2
OFFSET $3
`

type ListPatientVisitsByDoctorIDParams struct {
	DoctorID pgtype.UUID
	Limit    int32
	Offset   int32
}

type ListPatientVisitsByDoctorIDRow struct {
	ID               pgtype.UUID
	PatientID        pgtype.UUID
	DoctorID         pgtype.UUID
	VisitDate        pgtype.Timestamptz
	Symptoms         pgtype.Text
	Diagnosis        pgtype.Text
	Prescription     pgtype.Text
	Notes            pgtype.Text
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	PatientFirstName string
	PatientLastName  string
}

func (q *Queries) ListPatientVisitsByDoctorID(ctx context.Context, arg ListPatientVisitsByDoctorIDParams) ([]ListPatientVisitsByDoctorIDRow, error) {
	rows, err := q.db.Query(ctx, listPatientVisitsByDoctorID, arg.DoctorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatientVisitsByDoctorIDRow
	for rows.Next() {
		var i ListPatientVisitsByDoctorIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.VisitDate,
			&i.Symptoms,
			&i.Diagnosis,
			&i.Prescription,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PatientFirstName,
			&i.PatientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientVisitsByPatientID = `-- name: ListPatientVisitsByPatientID :many
SELECT pv.id, pv.patient_id, pv.doctor_id, pv.visit_date, pv.symptoms, pv.diagnosis, pv.prescription, pv.notes, pv.created_at, pv.updated_at, u.first_name as doctor_first_name, u.last_name as doctor_last_name
FROM patient_visits pv
JOIN users u ON pv.doctor_id = u.id -- Join to get doctor's name
WHERE pv.patient_id = $1
ORDER BY pv.visit_date DESC
LIMIT $2
OFFSET $3
`

type ListPatientVisitsByPatientIDParams struct {
	PatientID pgtype.UUID
	Limit     int32
	Offset    int32
}

type ListPatientVisitsByPatientIDRow struct {
	ID              pgtype.UUID
	PatientID       pgtype.UUID
	DoctorID        pgtype.UUID
	VisitDate       pgtype.Timestamptz
	Symptoms        pgtype.Text
	Diagnosis       pgtype.Text
	Prescription    pgtype.Text
	Notes           pgtype.Text
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	DoctorFirstName pgtype.Text
	DoctorLastName  pgtype.Text
}

func (q *Queries) ListPatientVisitsByPatientID(ctx context.Context, arg ListPatientVisitsByPatientIDParams) ([]ListPatientVisitsByPatientIDRow, error) {
	rows, err := q.db.Query(ctx, listPatientVisitsByPatientID, arg.PatientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatientVisitsByPatientIDRow
	for rows.Next() {
		var i ListPatientVisitsByPatientIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.VisitDate,
			&i.Symptoms,
			&i.Diagnosis,
			&i.Prescription,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DoctorFirstName,
			&i.DoctorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePatientVisit = `-- name: UpdatePatientVisit :one
UPDATE patient_visits
SET
    visit_date = COALESCE($1, visit_date),
    symptoms = COALESCE($2, symptoms),
    diagnosis = COALESCE($3, diagnosis),
    prescription = COALESCE($4, prescription),
    notes = COALESCE($5, notes),
    updated_at = NOW()
WHERE id = $6
RETURNING id, patient_id, doctor_id, visit_date, symptoms, diagnosis, prescription, notes, created_at, updated_at
`

type UpdatePatientVisitParams struct {
	VisitDate    pgtype.Timestamptz
	Symptoms     pgtype.Text
	Diagnosis    pgtype.Text
	Prescription pgtype.Text
	Notes        pgtype.Text
	ID           pgtype.UUID
}

func (q *Queries) UpdatePatientVisit(ctx context.Context, arg UpdatePatientVisitParams) (PatientVisit, error) {
	row := q.db.QueryRow(ctx, updatePatientVisit,
		arg.VisitDate,
		arg.Symptoms,
		arg.Diagnosis,
		arg.Prescription,
		arg.Notes,
		arg.ID,
	)
	var i PatientVisit
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.VisitDate,
		&i.Symptoms,
		&i.Diagnosis,
		&i.Prescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
